# Clean and Explore

Cleaning a data set, including fields and reshaping of the data, is a fundamental skill in order to get the data into an analyzable format. Real world data is rarely clean or analyzable immediately after downloading. As for exploring data, there is no quick, one-click method to explore your data, whether at a high level or in more granular detail. We will outline both in this chapter - iterating through cleaning and exploration before will generally be needed before you get the data into a final, testable state. 

For this section we will still use the General Ledger (GL) database, along with some more packages.

```{r, message = FALSE, warning = FALSE}
library(dplyr) # For manipulating data
library(tidyr) # For making data long and wide

library(lubridate) # For date handling
library(ggplot2) # For making visualizations

library(DBI) # For database connections

dir.create("data", showWarnings = FALSE)

download.file(url = "https://github.com/jonlinca/auditanalytics/raw/master/data/rauditanalytics.sqlite",
             destfile = "data/rauditanalytics.sqlite", mode = "wb")

con <- dbConnect(RSQLite::SQLite(), "data/rauditanalytics.sqlite")

gl <- tbl(con, 'gl') %>%
  collect()
```

## Basic math

We covered some of the basic operators in R in the Completeness chapter, so we'll cover some more calculations and transformations.

```{r}
x <- c(1, 2, 3)
y <- c(4, 5, 6)
```

The basic mathematical symbols will calculate a vector with a position element against a different vector with the same position. In this case, the first number in `x` is added to the first number in `y` resulting in the first calculation, the second number in `x` is added to the second number in `y` resulting in the second calculation, and so on.

```{r}
y + x
```

This distinction is important - vectorization allows R to be fast, but it changes how the user needs to understand objects.

`sum()` is fairly straight forward - it will add all the elements given, together:

```{r}
sum(x)
```

If you specify multiple vectors - it will merely combine them all together, equivalent to `sum(c(1, 2, 3), c(4, 5, 6))`:

```{r}
sum(x, y)
```

We mentioned in the prior chapter about NA values, which were 'Not Available' or Missing Values. It becomes important to understand the implication of them in your calculations. For example, when a NA value exists in a vector, you will get an NA by default:

```{r}
z <- c(1, 2, NA)
sum(z)
```

While `sum()`, and several other functions like `mean()`, `min()` and `max()` all generally behave in predictable manners, they all have an argument of `na.rm = FALSE` by default (enter `?sum` to see this argument in the help file. The reason why `FALSE` is by default is that it brings attention to the vector missing values. If you want to perform the calculation on this, you either need to substitute the `NA` out for a value (imputation), or simply ignore them. Both these decisions require professional judgment before substitution or ignoring. To substitute `NA` for a value (for example, 10):

```{r}
is.na(z) # Shows which positions in the vector have an NA value
z[is.na(z)] <- 10 # Where the z value is is.na, assign 10
sum(z)
```

Or alternatively, set the argument `na.rm = TRUE` to throw away these values completely:

```{r}
z <- c(1, 2, NA)
sum(z, na.rm = TRUE)
```

## Dates and Times

Unlike numbers, date and times are inherently more complex. They require many additional considerations to properly wrangle:

- What format is the date and time in?
- Are the timezones as expected? This also applies for dates.
- Do you want the the month the transaction took place in? The year? The day-of-week?
- Do you care about daylight savings time?

Starting with a basic example, lets understand the basic characteristics of dates. When you define a new date, the `lubridate::as_date()` function (or base `as.Date()`) works to convert character strings to dates.

```{r}
startString <- '2020-07-30' # ISO 8601 standards, follow them

# base::as.Date(startString) # Same thing as as_date, for now...
start <- lubridate::as_date(startString)

class(start)
```

You can convert any date to a date, as long as you specify the mask or format. A mask specifies where the date, month, year exist (as well as for time, hours, minutes, seconds). If you check the help file for `?strptime`, you will see several different formats for both specifying dates and times. For example, `%Y` is a four digit year while `%y%` is a two digit year. Here are a few examples with the same date (some are more unreasonable than others, but all can be captured):

```{r, eval = FALSE}
lubridate::as_date('2020-07-30', format = "%Y-%m-%d")
lubridate::as_date('30/07/2020', format = "%d/%m/%Y") # Not ISO 8601
lubridate::as_date('July 30, 20', format = "%B %d, %y") # Really not ISO 8601
lubridate::as_date('Jul3020', format = "%b%d%y") # Definitely not ISO 8601
lubridate::as_date('20212', format = "%y%j") # Looks like Julian
```

The same concept also applies to datetimes, where you can convert a given time to a 'POSIXct' or 'POSIXlt' format (the differences between 'POSIXct' and 'POSIXlt' are found in `?DateTimeClasses`, under details):

```{r}
starttime_base <- as.POSIXct('2020-07-30 12:00:00')
starttime_lub <- lubridate::as_datetime('2020-07-30 12:00:00')

class(starttime_base); class(starttime_lub)
```

And format masks apply as well to date time, just in case you get something unconventional:

```{r}
lubridate::as_datetime('2020-07-30 12:00:00 PM -0600', 
                       format = "%Y-%m-%d %I:%M:%S %p %z")
```

### Understanding Default Time Zones

Did you consider the time zone that the times were created in? This is system-specific and base `POSIXct` and lubridate `as_datetime` behave differently, so you have to be careful!

```{r}
print(starttime_base); attr(starttime_base,"tzone")
```

Notice that base treats the creation of the current timezone based off your local R machine, although its not extractable (and you will eventually find, hard to change).

```{r}
print(starttime_lub); tz(starttime_lub)
```

The lubridate version will assign the date-time automatically to UTC, unless you specify it. It is for this reason you will generally want to avoid using base R to convert to date times, and stick with lubridate for better predictability.

Having an automatic conversion to UTC isn't bad per se - having a universal ground truth to UTC is good, as it removes Daylight Saving component, and is an easy way to standardize multiple data sets together. Unfortunately, many systems will not tell you what time zone their data is in, so you will have to figure it out and ensure R is aligned accordingly.

### Override or display timezones

Hopefully you have been convinced to stick with lubridate for your date transformations. Now, lets get some confidence on these timezone transformations.

The first method is `force_tz()`, which forces the current time to become that same hour in a new timezone. When we assigned July 30th to the date, we would have assumed this date would have been in the current timezone we exist in (generally, the system time-zone you are in). To do this, specify the date, but also the time zone you want the date or time to be harmonized in:

```{r}
starttime_lub # Starts as UTC
force_tz(starttime_lub, tz = 'Canada/Mountain') # Force the saved time to be Mountain
```

Alternatively, you may wish to only convert the time so its displayed in the correct timezone, but leave the base truth as is. `with_tz()` will allow you to change the timezone that is displayed, while honoring the original time in the data.

```{r}
starttime_lub
with_tz(starttime_lub, tz = 'Canada/Mountain') # Display the current time as Mountain
```

### Daylight Saving Implications

There are also timezone implications when it comes to daylight saving time too. This is especially important when making audit decisions based on duration, or expected local norms for time-of-day.

For example, your staff may start their day at 8:00 AM locally. When Daylight Saving kicks in, the local time stays at 8:00 AM and the UTC time shifts from 15:00 to 14:00.

```{r}
pre <- as_datetime('2020-03-07 8:00:00', tz = 'Canada/Mountain') # The day before DST starts
post <- as_datetime('2020-03-08 8:00:00', tz = 'Canada/Mountain') # The day DST started

dst(pre); with_tz(pre, tz = 'UTC') # Was DST active before? ; What is the UTC time before? 
dst(post); with_tz(post, tz = 'UTC') # Was DST active after? ; What is the UTC time after?
```

### Differences between time

Another common request is to calculate the time differences between two dates. This seemingly simple action has several interpretations behind it. Do you want relative dates? Do you want exact elapsed time?

> People are not always consistent in how they expect time to behave. Sometimes the passage of time is a monotone progression of instants that should be as mathematically reliable as the number line. On other occasions time must follow complex conventions and rules so that the clock times we see reflect what we expect to observe in terms of daylight, season, and congruence with the atomic clock. [@lubridate-help]

Adding time is easy - you simply need to decide if you're adding a period (i.e. human construct of days) or if you are following physical time (i.e. seconds). The main difference is choosing lubridate's functions that honor periods or durations

```{r}
pre <- as_datetime('2020-03-07 8:00:00', tz = 'Canada/Mountain') # The day before DST starts
post <- as_datetime('2020-03-08 8:00:00', tz = 'Canada/Mountain') # The day DST started, skipped ahead 1 hour

# Periods: Human construct of days
pre + days(1) ; pre + hours(24) # Equal to post, the human construct

# Duration: Physical construct of time
pre + ddays(1) ; pre + dhours(24) # NOT to post, but actually 1 hour after
```

Calculating intervals and periods is a bit different. If we go back up to our example of pre-and-post daylight saving time, we can either expect this answer to be 1 day or 23 hours. Again, depending on your use case, it is up to you.^[Division is the intended mechanism - see https://github.com/tidyverse/lubridate/issues/105 and https://stackoverflow.com/questions/8765621/length-of-lubridate-interval]

```{r}
span <- interval(pre, post)

# Period: To find the number of days, in human constructs
span / days(1) # Period calculation by days. 

# Duration - To find the hours between, in physical constructs
as.duration(span)
```

### Derived date information

A common request for auditors is to find out the month a transaction took place in. With lubridate, its quite straight forward - for example, to extract the month, you don't need to have any messy substrings (or to extract other useful times, for that matter):

```{r}
thedate <- as_datetime('2020-07-01 12:00:00', tz = 'Canada/Mountain') 

month(thedate)
year(thedate)
quarter(thedate) # Canada Day starts on the first day of the third quarter. Does your company Financial Year not start on January 1? Just change the fiscal_start argument.
wday(thedate, label = TRUE)
```

## Pivot Wider
## Pivot Longer
## Separate
## Separate_rows

## Summary Statistics

## Anscombe's Quartet

## Graphics

## Summarize

## Join
- to vendor master to explore longer term trends